import type { ComplexityInfo } from "../types";

export const COMPLEXITIES: Record<string, ComplexityInfo> = {
    "bubble-sort": {
        name: "Bubble Sort",
        category: "comparison",
        bestTime: "O(n)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: true,
        inPlace: true,
        adaptive: true,
        notes: "Simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.",
    },
    "selection-sort": {
        name: "Selection Sort",
        category: "comparison",
        bestTime: "O(n²)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Repeatedly finds the minimum element from unsorted part and puts it at the beginning.",
    },
    "insertion-sort": {
        name: "Insertion Sort",
        category: "comparison",
        bestTime: "O(n)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: true,
        inPlace: true,
        adaptive: true,
        notes: "Builds the final sorted array one item at a time. Efficient for small data sets.",
    },
    "merge-sort": {
        name: "Merge Sort",
        category: "comparison",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n log n)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Divide and conquer algorithm. Reliable O(n log n) performance but requires O(n) extra space.",
    },
    "quick-sort": {
        name: "Quick Sort",
        category: "comparison",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n²)",
        space: "O(log n)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Divide and conquer. Pivoting strategy affects performance. Usually the fastest in practice.",
    },
    "heap-sort": {
        name: "Heap Sort",
        category: "comparison",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n log n)",
        space: "O(1)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Uses a binary heap data structure. Excellent worst-case performance but often slower than QuickSort in practice.",
    },
    "counting-sort": {
        name: "Counting Sort",
        category: "non-comparison",
        bestTime: "O(n+k)",
        avgTime: "O(n+k)",
        worstTime: "O(n+k)",
        space: "O(k)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Non-comparison sort. Very fast when range of input (k) is not significantly greater than number of elements (n).",
    },
    "radix-sort": {
        name: "Radix Sort",
        category: "non-comparison",
        bestTime: "O(nk)",
        avgTime: "O(nk)",
        worstTime: "O(nk)",
        space: "O(n+k)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Sorts integers by processing individual digits. 'k' is the number of digits.",
    },
    "bucket-sort": {
        name: "Bucket Sort",
        category: "non-comparison",
        bestTime: "O(n+k)",
        avgTime: "O(n)",
        worstTime: "O(n²)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Distributes elements into buckets, then sorts buckets. Effective for uniformly distributed data.",
    },
    "shell-sort": {
        name: "Shell Sort",
        category: "comparison",
        bestTime: "O(n log n)",
        avgTime: "O(n log² n)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: false,
        inPlace: true,
        adaptive: true,
        notes: "Generalization of insertion sort. Allows exchange of items that are far apart.",
    },
    "gnome-sort": {
        name: "Gnome Sort",
        category: "comparison",
        bestTime: "O(n)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: true,
        inPlace: true,
        adaptive: true,
        notes: "Similar to insertion sort except moving an element to its proper place is accomplished by a series of swaps.",
    },
    "cocktail-sort": {
        name: "Cocktail Shaker Sort",
        category: "comparison",
        bestTime: "O(n)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: true,
        inPlace: true,
        adaptive: true,
        notes: "Variation of bubble sort that sorts in both directions on each pass.",
    },
    "odd-even-sort": {
        name: "Odd-Even Sort",
        category: "comparison",
        bestTime: "O(n)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: true,
        inPlace: true,
        adaptive: true,
        notes: "Parallel variation of bubble sort. Compares all odd/even indexed pairs of adjacent elements.",
    },
    "comb-sort": {
        name: "Comb Sort",
        category: "comparison",
        bestTime: "O(n log n)",
        avgTime: "O(n²/2^p)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Improves on Bubble Sort by eliminating turtles, or small values near the end of the list.",
    },
    "cycle-sort": {
        name: "Cycle Sort",
        category: "comparison",
        bestTime: "O(n²)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Optimal for minimizing the total number of writes to the array.",
    },
    "pancake-sort": {
        name: "Pancake Sort",
        category: "comparison",
        bestTime: "-",
        avgTime: "-",
        worstTime: "O(n)",
        space: "O(1)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Sorts correctly by only reversing the first n elements (flipping pancakes).",
    },
    "stooge-sort": {
        name: "Stooge Sort",
        category: "comparison",
        bestTime: "-",
        avgTime: "O(n^2.7)",
        worstTime: "O(n^2.7)",
        space: "O(n)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "A recursive sorting algorithm with very poor time complexity.",
    },
    "bitonic-sort": {
        name: "Bitonic Sort",
        category: "parallel",
        bestTime: "O(log^2 n)",
        avgTime: "O(log^2 n)",
        worstTime: "O(log^2 n)",
        space: "O(n log^2 n)",
        stable: false,
        inPlace: false,
        adaptive: false,
        notes: "Designed for parallel computing. Builds a bitonic sequence and then merges it.",
    },
    "tree-sort": {
        name: "Tree Sort",
        category: "comparison",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n²)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Builds a Binary Search Tree from elements, then performs in-order traversal.",
    },
    "pigeonhole-sort": {
        name: "Pigeonhole Sort",
        category: "non-comparison",
        bestTime: "O(n+N)",
        avgTime: "O(n+N)",
        worstTime: "O(n+N)",
        space: "O(N)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Suitable when range of keys (N) is approximately equal to number of elements (n).",
    },
    "strand-sort": {
        name: "Strand Sort",
        category: "comparison",
        bestTime: "O(n)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: true,
        notes: "Recursively pulls sorted sub-lists (strands) and merges them.",
    },
    "bingo-sort": {
        name: "Bingo Sort",
        category: "comparison",
        bestTime: "O(n+k)",
        avgTime: "O(n+k)",
        worstTime: "O(mn)",
        space: "O(1)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Variation of Selection Sort efficiently scanning for remaining largest values.",
    },
    "timsort": {
        name: "TimSort",
        category: "hybrid",
        bestTime: "O(n)",
        avgTime: "O(n log n)",
        worstTime: "O(n log n)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: true,
        notes: "Hybrid of Merge Sort and Insertion Sort. Standard sort in Python, Java, etc.",
    },
    "introsort": {
        name: "IntroSort",
        category: "hybrid",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n log n)",
        space: "O(log n)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Begins with QuickSort and switches to HeapSort when recursion depth exceeds a level.",
    },
    "merge-insertion-sort": {
        name: "Merge + Insertion Hybrid",
        category: "hybrid",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n log n)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Uses Insertion Sort for small subarrays to improve Merge Sort performance.",
    },
    "quick-insertion-sort": {
        name: "Quick + Insertion Hybrid",
        category: "hybrid",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n²)",
        space: "O(log n)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Uses Insertion Sort for small partitions to improve Quick Sort performance.",
    },
    "dual-pivot-quick-sort": {
        name: "Dual-Pivot Quick Sort",
        category: "hybrid",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n²)",
        space: "O(log n)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Partitions the array into three parts using two pivots.",
    },
    "block-merge-sort": {
        name: "Block Merge Sort",
        category: "hybrid",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n log n)",
        space: "O(1)",
        stable: true,
        inPlace: true,
        adaptive: false,
        notes: "Merge Sort variant designed to be in-place (O(1) space). Visualization simplified.",
    },
    "adaptive-radix-sort": {
        name: "Adaptive Radix Sort",
        category: "hybrid",
        bestTime: "O(nk)",
        avgTime: "O(nk)",
        worstTime: "O(nk)",
        space: "O(n+k)",
        stable: true,
        inPlace: false,
        adaptive: true,
        notes: "MSD Radix Sort that adapts relative to digit position range.",
    },
    "bucket-insertion-sort": {
        name: "Bucket + Insertion Hybrid",
        category: "hybrid",
        bestTime: "O(n+k)",
        avgTime: "O(n)",
        worstTime: "O(n²)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Explicitly uses Insertion Sort to sort individual buckets.",
    },
    "radix-bucket-sort": {
        name: "Radix + Bucket Hybrid",
        category: "hybrid",
        bestTime: "O(nk)",
        avgTime: "O(nk)",
        worstTime: "O(nk)",
        space: "O(n+k)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Visualizes Radix Sort explicitly emphasizing bucket operations.",
    },
    "odd-even-merge-sort": {
        name: "Batcher's Odd-Even Merge",
        category: "parallel",
        bestTime: "O(log^2 n)",
        avgTime: "O(log^2 n)",
        worstTime: "O(log^2 n)",
        space: "O(n log^2 n)",
        stable: false,
        inPlace: false,
        adaptive: false,
        notes: "Parallel sorting network. Works best on power-of-2 arrays.",
    },
    "sample-sort": {
        name: "Sample Sort",
        category: "parallel",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n^2)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Parallel adaptation of QuickSort/BucketSort. Uses sampling to define buckets.",
    },
    "gpu-radix-sort": {
        name: "GPU Radix Sort",
        category: "parallel",
        bestTime: "O(nk)",
        avgTime: "O(nk)",
        worstTime: "O(nk)",
        space: "O(n+k)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Simulates parallel histogram and prefix sum passes typical of GPU sorting.",
    },
};
