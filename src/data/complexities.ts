import type { ComplexityInfo } from "../types";

export const COMPLEXITIES: Record<string, ComplexityInfo> = {
    "bubble-sort": {
        name: "Bubble Sort",
        category: "comparison",
        bestTime: "O(n)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: true,
        inPlace: true,
        adaptive: true,
        notes: "Simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.",
    },
    "selection-sort": {
        name: "Selection Sort",
        category: "comparison",
        bestTime: "O(n²)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Repeatedly finds the minimum element from unsorted part and puts it at the beginning.",
    },
    "insertion-sort": {
        name: "Insertion Sort",
        category: "comparison",
        bestTime: "O(n)",
        avgTime: "O(n²)",
        worstTime: "O(n²)",
        space: "O(1)",
        stable: true,
        inPlace: true,
        adaptive: true,
        notes: "Builds the final sorted array one item at a time. Efficient for small data sets.",
    },
    "merge-sort": {
        name: "Merge Sort",
        category: "comparison",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n log n)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Divide and conquer algorithm. Reliable O(n log n) performance but requires O(n) extra space.",
    },
    "quick-sort": {
        name: "Quick Sort",
        category: "comparison",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n²)",
        space: "O(log n)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Divide and conquer. Pivoting strategy affects performance. Usually the fastest in practice.",
    },
    "heap-sort": {
        name: "Heap Sort",
        category: "comparison",
        bestTime: "O(n log n)",
        avgTime: "O(n log n)",
        worstTime: "O(n log n)",
        space: "O(1)",
        stable: false,
        inPlace: true,
        adaptive: false,
        notes: "Uses a binary heap data structure. Excellent worst-case performance but often slower than QuickSort in practice.",
    },
    "counting-sort": {
        name: "Counting Sort",
        category: "non-comparison",
        bestTime: "O(n+k)",
        avgTime: "O(n+k)",
        worstTime: "O(n+k)",
        space: "O(k)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Non-comparison sort. Very fast when range of input (k) is not significantly greater than number of elements (n).",
    },
    "radix-sort": {
        name: "Radix Sort",
        category: "non-comparison",
        bestTime: "O(nk)",
        avgTime: "O(nk)",
        worstTime: "O(nk)",
        space: "O(n+k)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Sorts integers by processing individual digits. 'k' is the number of digits.",
    },
    "bucket-sort": {
        name: "Bucket Sort",
        category: "non-comparison",
        bestTime: "O(n+k)",
        avgTime: "O(n)",
        worstTime: "O(n²)",
        space: "O(n)",
        stable: true,
        inPlace: false,
        adaptive: false,
        notes: "Distributes elements into buckets, then sorts buckets. Effective for uniformly distributed data.",
    },
};
